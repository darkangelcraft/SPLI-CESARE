# coding=utf-8
import os
import glob
import json
import ast
import time

#
# def myThread1(story_bruteforce_positive):
#     wordp = story_bruteforce_positive.split()[i]
#     if dictionary.__contains__(wordp):
#         en_pos.append(True)
#     else:
#         en_pos.append(False)


# variabile globale che mi serve per identificare il libro scelto da cifrare
file_choosen = -1
# cosi non mi stampa anche STORY_CIPHER e STORY_CLEAR
books = glob.glob("*_.txt")

print '\nchoose:'

int_option = None
while int_option is None:

    print '0) dizionario'
    print '1) scegli file'
    print '2) cifra'
    print '3) decifra'
    print '4) invia'
    print '5) ricevi'
    print '6) attacco bruteforce'
    print '7) attacco per frequenza'

    try:
        option1 = raw_input()
    except SyntaxError:
        option = None

    if option1 == '0':
        print '1) per lettere'
        print '2) per parole'

        opt=raw_input()

        #### LETTERE ####
        if opt == '1':

            array_books = []
            story = []

            i = 0
            # scorro tutti i libri
            while i < 6:
                file = open(books[i], "r")
                # bisogna togliere la punteggiature [".", ";", ":", "!", "?", "/", "\\", ",", "#", "@", "$", "&", ")", "(", "\""]
                story.append(str(
                    file.read().lower().replace(".", " ").replace("'", " ").replace(";", " ").replace(":", " ").replace(
                        "!", " ").replace("?", " ").replace("/", " ").replace("'\'", " ").replace(',', " ").replace("#",
                                                                                                                    " ").replace(
                        "@", " ").replace("$", " ").replace("&", " ").replace(")", " ").replace('"', " ").replace("-",
                                                                                                                  " ").replace(
                        "°", " ").replace("(", " ").split()))

                # faccio un merge di tutti i libri
                #print ast.literal_eval(story[i])
                array_books.append(str(ast.literal_eval(story[i])))
                i += 1

            # creo array string con tutte le lettere di tutti i libri
            array_letters = ""

            j=0
            while j < 6:
                for word in ast.literal_eval(array_books[j]):
                    for c in word:
                        if c.isalpha():
                            array_letters += c + ' '
                j+=1

            print array_letters
            # adesso dell'array_letters ne calcolo le occorrenze
            alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't','u', 'v', 'w', 'x', 'y', 'z']

            #inizializzo file json
            data=[]

            with open('dictionary_letters.txt', 'w') as outfile:
                json_data = json.dumps(data)
                outfile.write(json_data)

            with open('dictionary_letters.txt') as input_file:
              data_loaded = json.load(input_file)

            k = 0
            while k < 26:
                print 'letter: '+alphabet[k]
                print 'occ: '+str(array_letters.count(alphabet[k]))
                print 'freq: '+str(round(float(array_letters.count(alphabet[k]))/float(len(array_letters))*100,2))
                print ''

                #aggiungo al file json il num di lettere, le sue occorrenze e la frequenza all'interno dei libri
                data.append({'letter':alphabet[k],'occ': array_letters.count(alphabet[k]),'freq':round(float(array_letters.count(alphabet[k]))/float(len(array_letters))*100,2)})
                k+=1

            ## Save our changes to JSON file
            jsonFile = open("dictionary_letters.txt", "w+")
            jsonFile.write(json.dumps(data))
            jsonFile.close()

            print "dictionary_letters created!\n\n"

        #### PAROLE #####
        elif opt == '2':

            array_without_occurence = ""
            story = []

            i=0
            #scorro tutti i libri
            while i < 6:
                file = open(books[i], "r")
                # bisogna togliere la punteggiature [".", ";", ":", "!", "?", "/", "\\", ",", "#", "@", "$", "&", ")", "(", "\""]
                story.append(str(file.read().lower().replace("."," ").replace("'"," ").replace(";"," ").replace(":"," ").replace("!"," ").replace("?"," ").replace("/"," ").replace("'\'"," ").replace(','," ").replace("#"," ").replace("@"," ").replace("$"," ").replace("&"," ").replace(")"," ").replace('"'," ").replace("-"," ").replace("°"," ").replace("("," ").split()))

                #aggiungo le parole non doppie
                for word in ast.literal_eval(story[i]):
                    if not array_without_occurence.__contains__(word):
                        array_without_occurence += word + '\n'

                #passo al libro sucessivo
                i+=1

            # scrivo e creo file cifrato
            file = open("dictionary_words.txt", "w")
            file.write(array_without_occurence)

            print "dictionary_words created!\n\n"

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    # stampo i file da selezionare1
    elif option1 == '1':
        i = 0
        for num in books:
            print '\t' + str(i) + ') ' + books[i]
            i = i + 1

        try:
            file_choosen = raw_input()
        except SyntaxError:
            option = None

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    # CIFRATURA
    elif option1 == '2':
        print 'the book choosen is: ' + books[int(file_choosen)]

        # aggiusto prima il file eliminando maiuscole al suo interno
        file = open(books[int(file_choosen)], "r+")
        story = file.read().lower()

        print 'insert OFFSET: (+2) (-2)'
        offset = raw_input()

        story_cipher = ""

        # ora scorro carattere per carattere e applico l offset alle lettere
        for c in story:
            # restituisce True se e un carattere ABCabc
            if c.isalpha():
                # ord('a') -> 97
                # chr(97 + 3) -> chr(100) -> 'd'

                # numero corrispondente in ASCII
                character = str(c)
                # print character
                old = ord(character)
                # print int(old)
                # numero shiftato destra o sinistra
                if offset.__contains__('+'):
                    new = int(old) + int(offset[1:])
                    if new > 122:
                        new = new - 26
                else:
                    new = int(old) - int(offset[1:])
                    if new < 97:
                        new = new + 26

                story_cipher = story_cipher + chr(new)
                # print chr(new)
            else:
                character = str(c)
                story_cipher = story_cipher + character

        # print story_cipher

        # scrivo e creo file cifrato
        file = open("STORY_CIPHER.txt", "w")
        file.write(story_cipher)

        print "story_cipher created!\n\n"

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    #DECIFRATURA
    elif option1 == '3':
        print 'the book to decipher is: ' + books[int(file_choosen)]

        # aggiusto prima il file eliminando maiuscole al suo interno
        file = open("STORY_CIPHER.txt", "r+")
        story = file.read()

        print 'insert OFFSET known:'
        offset = raw_input()

        story_clear = ""

        # inizio decifrazione avendo noto l'offset
        for c in story:
            # restituisce True se e un carattere ABCabc
            if c.isalpha():
                # ord('a') -> 97
                # chr(97 + 3) -> chr(100) -> 'd'

                # numero corrispondente in ASCII
                character = str(c)
                # print character
                old = ord(character)
                # print int(old)
                # numero shiftato destra o sinistra
                if offset.__contains__('+'):
                    new = int(old) + int(offset[1:])
                    if new > 122:
                        new = new - 26
                else:
                    new = int(old) - int(offset[1:])
                    if new < 97:
                        new = new + 26

                story_clear = story_clear + chr(new)
                # print chr(new)
            else:
                character = str(c)
                story_clear = story_clear + character

        # print story_clear

        # scrivo e creo file cifrato
        file = open("STORY_CLEAR.txt", "w")
        file.write(story_clear)

        print "story_clear created!\n\n"

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    elif option1 == '4':
        print 'waiting...'
        os.system('sudo nc -l -p 3333 | pv -rb > ' + books[int(file_choosen)])

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    elif option1 == '5':
        print 'sending with netcat'
        print "insert ip target:"
        ip = raw_input()
        os.system('sudo pv ' + books[int(file_choosen)] + ' | nc -w 1 ' + ip + ' 3333')

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    elif option1 == '6':
        print 'the book to hacking is: '+books[int(file_choosen)]+'\n'

        print books[int(file_choosen)]

        # apro il file cifrato
        file = open('STORY_CIPHER.txt', "r+")
        story_cipher = file.read()
        a=len(story_cipher)

        # (inizio il bruteforce!)
        file1 = open('dictionary_words.txt', "r+")
        dictionary = file1.read()

        #il bruteforce viene fatto due alla volta, ovvero per il numero 3 viene fatto sia (+3) che (-3)
        offset_bruteforce=1

        while offset_bruteforce < 27:

            t1 = time.time()

            story_bruteforce_positive = ""
            story_bruteforce_negative = ""

            # inizio decifrazione avendo noto l'offset
            for c in story_cipher:
                # restituisce True se e un carattere ABCabc
                if c.isalpha():
                    # ord('a') -> 97
                    # chr(97 + 3) -> chr(100) -> 'd'

                    # numero corrispondente in ASCII
                    character = str(c)
                    # print character
                    old = ord(character)
                    # print int(old)

                    # numero shiftato destra
                    new_positive = int(old) + offset_bruteforce
                    if new_positive > 122:
                        new_positive = new_positive - 26

                    # numero shiftato a sinistra
                    new_negative = int(old) - offset_bruteforce
                    if new_negative < 97:
                        new_negative = new_negative + 26

                    story_bruteforce_positive = story_bruteforce_positive + chr(new_positive)
                    story_bruteforce_negative = story_bruteforce_negative + chr(new_negative)
                    # print chr(new)

                #e un carattere lo lascio cosi
                else:
                    character = str(c)
                    story_bruteforce_positive = story_bruteforce_positive + character
                    story_bruteforce_negative = story_bruteforce_negative + character

            #mi faccio due array di 0 e 1 in base a SI appartiene alla lista o NO non appartiane
            en_pos=[]
            en_neg=[]


            i=0
            n=len(story_bruteforce_positive.split())
            # visto che hanno entrambe uguale lunghezza
            # posso usare direttamente la meta della parole tanto sono sufficienti per far match con il dizionario
            # per velocizzarlo di quasi 2s posso anche arrivare a n/3,n/4 perche sarebbero 2000 parole
            # n/10 equivale a 1000 parole e sono abbastanza
            print "n-->"+str(n/10)
            while i < n/10:
                
                wordp=story_bruteforce_positive.split()[i]
                if dictionary.__contains__(wordp):
                    en_pos.append(True)
                else:
                    en_pos.append(False)

                wordn = story_bruteforce_negative.split()[i]
                if dictionary.__contains__(wordn):
                    en_neg.append(True)
                else:
                    en_neg.append(False)
                i += 1

            percent_plus = (float(en_pos.count(True))/float(len(en_pos)))*100
            percent_minus= (float(en_neg.count(True))/float(len(en_neg)))*100

            if int(percent_plus) > 80:
                print "# FIND! #"
                print 'the offset used is (-' + str(offset_bruteforce) + ')\n'

                # scrivo e creo file cifrato
                file = open("STORY_BRUTEFORCE.txt", "w")
                file.write(story_bruteforce_positive)

                offset_bruteforce = 28

            elif int(percent_minus) > 80:
                print "# FIND! #"
                print 'the offset used is (+' + str(offset_bruteforce) + ')\n'

                # scrivo e creo file cifrato
                file = open("STORY_BRUTEFORCE.txt", "w")
                file.write(story_bruteforce_negative)

                offset_bruteforce = 28

            print str(round((time.time() - t1), 1)) + 's'
            #fallito passo all offset successivo
            offset_bruteforce+=1

        print "story_bruteforce created!\n\n"

    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    elif option1 == '7':
        print 'the book to hacking is: ' + books[int(file_choosen)] + '\n'

        print books[int(file_choosen)]

        # apro il file cifrato
        file = open('STORY_CIPHER.txt', "r+")
        story_cipher = file.read()
        a = len(story_cipher)

        #inizio attacco per frequenza
    # o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o o #

    else:
        print "ERROR"
